// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	char_vs_rune "github.com/tamarakaufler/grpc-char-vs-rune/client/char-vs-rune"
	"google.golang.org/grpc"
)

type Mock struct {
	ToCharStub        func(context.Context, *char_vs_rune.ToCharRequest, ...grpc.CallOption) (*char_vs_rune.ToCharResponse, error)
	toCharMutex       sync.RWMutex
	toCharArgsForCall []struct {
		arg1 context.Context
		arg2 *char_vs_rune.ToCharRequest
		arg3 []grpc.CallOption
	}
	toCharReturns struct {
		result1 *char_vs_rune.ToCharResponse
		result2 error
	}
	toCharReturnsOnCall map[int]struct {
		result1 *char_vs_rune.ToCharResponse
		result2 error
	}
	ToRuneStub        func(context.Context, *char_vs_rune.ToRuneRequest, ...grpc.CallOption) (*char_vs_rune.ToRuneResponse, error)
	toRuneMutex       sync.RWMutex
	toRuneArgsForCall []struct {
		arg1 context.Context
		arg2 *char_vs_rune.ToRuneRequest
		arg3 []grpc.CallOption
	}
	toRuneReturns struct {
		result1 *char_vs_rune.ToRuneResponse
		result2 error
	}
	toRuneReturnsOnCall map[int]struct {
		result1 *char_vs_rune.ToRuneResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Mock) ToChar(arg1 context.Context, arg2 *char_vs_rune.ToCharRequest, arg3 ...grpc.CallOption) (*char_vs_rune.ToCharResponse, error) {
	fake.toCharMutex.Lock()
	ret, specificReturn := fake.toCharReturnsOnCall[len(fake.toCharArgsForCall)]
	fake.toCharArgsForCall = append(fake.toCharArgsForCall, struct {
		arg1 context.Context
		arg2 *char_vs_rune.ToCharRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ToCharStub
	fakeReturns := fake.toCharReturns
	fake.recordInvocation("ToChar", []interface{}{arg1, arg2, arg3})
	fake.toCharMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Mock) ToCharCallCount() int {
	fake.toCharMutex.RLock()
	defer fake.toCharMutex.RUnlock()
	return len(fake.toCharArgsForCall)
}

func (fake *Mock) ToCharCalls(stub func(context.Context, *char_vs_rune.ToCharRequest, ...grpc.CallOption) (*char_vs_rune.ToCharResponse, error)) {
	fake.toCharMutex.Lock()
	defer fake.toCharMutex.Unlock()
	fake.ToCharStub = stub
}

func (fake *Mock) ToCharArgsForCall(i int) (context.Context, *char_vs_rune.ToCharRequest, []grpc.CallOption) {
	fake.toCharMutex.RLock()
	defer fake.toCharMutex.RUnlock()
	argsForCall := fake.toCharArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Mock) ToCharReturns(result1 *char_vs_rune.ToCharResponse, result2 error) {
	fake.toCharMutex.Lock()
	defer fake.toCharMutex.Unlock()
	fake.ToCharStub = nil
	fake.toCharReturns = struct {
		result1 *char_vs_rune.ToCharResponse
		result2 error
	}{result1, result2}
}

func (fake *Mock) ToCharReturnsOnCall(i int, result1 *char_vs_rune.ToCharResponse, result2 error) {
	fake.toCharMutex.Lock()
	defer fake.toCharMutex.Unlock()
	fake.ToCharStub = nil
	if fake.toCharReturnsOnCall == nil {
		fake.toCharReturnsOnCall = make(map[int]struct {
			result1 *char_vs_rune.ToCharResponse
			result2 error
		})
	}
	fake.toCharReturnsOnCall[i] = struct {
		result1 *char_vs_rune.ToCharResponse
		result2 error
	}{result1, result2}
}

func (fake *Mock) ToRune(arg1 context.Context, arg2 *char_vs_rune.ToRuneRequest, arg3 ...grpc.CallOption) (*char_vs_rune.ToRuneResponse, error) {
	fake.toRuneMutex.Lock()
	ret, specificReturn := fake.toRuneReturnsOnCall[len(fake.toRuneArgsForCall)]
	fake.toRuneArgsForCall = append(fake.toRuneArgsForCall, struct {
		arg1 context.Context
		arg2 *char_vs_rune.ToRuneRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ToRuneStub
	fakeReturns := fake.toRuneReturns
	fake.recordInvocation("ToRune", []interface{}{arg1, arg2, arg3})
	fake.toRuneMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Mock) ToRuneCallCount() int {
	fake.toRuneMutex.RLock()
	defer fake.toRuneMutex.RUnlock()
	return len(fake.toRuneArgsForCall)
}

func (fake *Mock) ToRuneCalls(stub func(context.Context, *char_vs_rune.ToRuneRequest, ...grpc.CallOption) (*char_vs_rune.ToRuneResponse, error)) {
	fake.toRuneMutex.Lock()
	defer fake.toRuneMutex.Unlock()
	fake.ToRuneStub = stub
}

func (fake *Mock) ToRuneArgsForCall(i int) (context.Context, *char_vs_rune.ToRuneRequest, []grpc.CallOption) {
	fake.toRuneMutex.RLock()
	defer fake.toRuneMutex.RUnlock()
	argsForCall := fake.toRuneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Mock) ToRuneReturns(result1 *char_vs_rune.ToRuneResponse, result2 error) {
	fake.toRuneMutex.Lock()
	defer fake.toRuneMutex.Unlock()
	fake.ToRuneStub = nil
	fake.toRuneReturns = struct {
		result1 *char_vs_rune.ToRuneResponse
		result2 error
	}{result1, result2}
}

func (fake *Mock) ToRuneReturnsOnCall(i int, result1 *char_vs_rune.ToRuneResponse, result2 error) {
	fake.toRuneMutex.Lock()
	defer fake.toRuneMutex.Unlock()
	fake.ToRuneStub = nil
	if fake.toRuneReturnsOnCall == nil {
		fake.toRuneReturnsOnCall = make(map[int]struct {
			result1 *char_vs_rune.ToRuneResponse
			result2 error
		})
	}
	fake.toRuneReturnsOnCall[i] = struct {
		result1 *char_vs_rune.ToRuneResponse
		result2 error
	}{result1, result2}
}

func (fake *Mock) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.toCharMutex.RLock()
	defer fake.toCharMutex.RUnlock()
	fake.toRuneMutex.RLock()
	defer fake.toRuneMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Mock) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ char_vs_rune.CharVsRuneClient = new(Mock)
